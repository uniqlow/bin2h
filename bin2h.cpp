/**
 * A utility to convert a binary file to a standard C header file.
 *
 * Useful for embedding eg assets directly in an executable file.
 */

#include <fstream>
#include <algorithm>
#include <string>
#include <vector>
#include <cstring>
#include <cstdio>
#include <cerrno>

namespace {

static
void
usage()
{
	std::fprintf(stderr, "usage: bin2h [option] <inputfile> <output name>\n");
	std::fprintf(stderr, "options:\n");
	std::fprintf(stderr, " -f       overwrite output files even if they already exists\n");
}

} // !namespace

int
main(int const argc, char** const argv)
{
	if (argc != 3 && argc != 4) {
		usage();
		return -1;
	}

	char const * const option = argc == 4 ? argv[1] : nullptr;
	unsigned const argOffset = option ? 2 : 1;

	bool overwrite = false;
	if (option) {
		if (std::strcmp(option, "-f") == 0) {
			overwrite = true;
		} else {
			usage();
			return -1;
		}
	}

	char const * const inFilename = argv[argOffset];
	std::string name = argv[argOffset + 1];
	std::replace(name.begin(), name.end(), '.', '_');
	std::string const outFilenameStr = name + ".h";
	std::string const outImplFilenameStr = name + "_impl.h";
	char const * const outFilename = outFilenameStr.c_str();
	char const * const outImplFilename = outImplFilenameStr.c_str();

	std::ifstream ifs(inFilename, std::ios::binary);
	if (ifs.fail()) {
		std::fprintf(stderr, "Error: failed to open file '%s'\n", inFilename);
		return -1;
	}
	std::vector<char> content((std::istreambuf_iterator<char>(ifs)), std::istreambuf_iterator<char>());
	if (content.empty()) {
		std::fprintf(stderr, "Error: failed to read file '%s'\n", inFilename);
		return -1;
	}
	unsigned const inSize = (unsigned)content.size();

	if (!overwrite && std::fopen(outFilename, "r")) {
		std::fprintf(stderr, "Error: output file '%s' already exists, refusing to overwrite it\n", outFilename);
		return -1;
	}

	if (!overwrite && std::fopen(outImplFilename, "r")) {
		std::fprintf(stderr, "Error: output implementation file '%s' already exists, refusing to overwrite it\n", outImplFilename);
		return -1;
	}

	FILE * const outf = std::fopen(outFilename, "w");
	if (!outf) {
		std::fprintf(stderr, "Error: failed to open file '%s'\n", outFilename);
		return -1;
	}

	FILE * const outimplf = std::fopen(outImplFilename, "w");
	if (!outimplf) {
		std::fprintf(stderr, "Error: failed to open implementation file '%s'\n", outImplFilename);
		return -1;
	}

	std::fprintf(
		outf,
		"/* Auto-generated by bin2h */\n\n"
		"#ifndef %s_h\n#define %s_h\n\n"
		"#ifdef __cplusplus\n"
		"extern \"C\" {\n"
		"#endif\n\n"
		"extern unsigned char const %s[];\n"
		"enum { %s_SIZE = %u };\n\n"
		"#ifdef __cplusplus\n"
		"}\n"
		"#endif\n\n"
		"#endif\n",
		name.c_str(), name.c_str(), name.c_str(), name.c_str(), inSize);
	std::fclose(outf);

	std::fprintf(outimplf,
		     "/* Auto-generated by bin2h */\n\n"
		     "unsigned char const %s[] = {\n",
		     name.c_str());

	for (unsigned writtenBytes = 0; writtenBytes < inSize;) {
		if (writtenBytes != 0) {
			std::fputs(",\n\t", outimplf);
		} else {
			std::fputc('\t', outimplf);
		}
		for (unsigned i = 0; i < 11 && writtenBytes < inSize; ++i, ++writtenBytes) {
			if (i != 0) {
				std::fprintf(outimplf, ", 0x%02x", (unsigned char)content[writtenBytes]);
			} else {
				std::fprintf(outimplf, "0x%02x", (unsigned char)content[writtenBytes]);
			}
		}
	}
	std::fputs("\n};\n", outimplf);

	std::fclose(outimplf);
}
